\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{ibf}

\bibliographystyle{plain}

\author{Filip BÃ¡rtek}
\title{Minimal \acrshort{dnf} representation of false point interval Boolean functions}

\begin{document}
\maketitle

\section{Introduction}
When we identify binary vectors with the numbers they express in binary form,
we can define $n$-ary Boolean functions
as functions from $\{0, \ldots, 2^n - 1\}$ to the Boolean domain.
We continue to define \emph{false point interval Boolean functions}
as functions whose \emph{false} points,
when considered numbers,
form a single interval.

In this text,
I will show an efficient algorithm
for construction of minimal \acrshort{dnf} representation
(i.e.~one with the least clauses)
of false point interval Boolean functions.
Doing so, I will simplify the method shown in \cite{Dubovsky2012}.
I will build on the results about true point interval Boolean functions
shown in \cite{Schieber2005154}.

\section{Definitions}
% TODO: Define interval (esp. inclusiveness of boundary values)

\begin{definition}[Interval Boolean function]
Let $a \leq b$ be $n$-bit numbers ($0 \leq a \leq b \leq 2^n - 1$).
Then $f^n_{\interval{a}{b}}: \booldom{}^n \rightarrow \booldom{}$ is a function defined as follows:
% http://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#Using_aligned_braces_for_piecewise_functions
% http://en.wikipedia.org/wiki/Piecewise
\[f^n_{\interval{a}{b}} (x) = \left\{
  \begin{array}{lr}
    1 & $if $ x \in \interval{a}{b}\\
    0 & $otherwise$
  \end{array}
\right.
\]
\end{definition}

% TODO: Define interval complement `\finterval{a}{b}`

\begin{definition}[False point interval Boolean function]
Let $a \leq b$ be $n$-bit numbers ($0 \leq a \leq b \leq 2^n - 1$).
Then $f^n_{\finterval{a}{b}}: \booldom{}^n \rightarrow \booldom{}$ is a function defined as follows:
\[f^n_{\finterval{a}{b}} (x) = \left\{
  \begin{array}{lr}
    1 & $if $ x \notin \interval{a}{b}\\
    0 & $otherwise$
  \end{array}
\right.
\]
\end{definition}

% TODO: Define `span(T)`

Definitions of
ternary vectors,
spanning,
bit extraction $\bit{a}{i}$,
sequence extraction $\bits{a}{i}{j}$,
vector complement $\compl{a}$
etc.~are shown in \cite{Schieber2005154}.

\section{Spanning false point interval Boolean functions}
Let $n \geq 0$ and $0 \leq a \leq b \leq 2^n - 1$.
We need to find a set of ternary vectors of minimal cardinality
that spans exactly $\finterval{a}{b} = \interval{0}{a-1} \cup \interval{b+1}{2^n - 1}$.

Since we'll solve the problem recursively,
let's first simply observe that the optimal spanning set of a $0$-bit Boolean function ($n = 0$)
is an empty set.
From now on, let $n \geq 1$.

We'll consider two cases separately:

\begin{enumerate}
\item $\bit{a}{1} = \bit{b}{1}$
\item $\bit{a}{1} \neq \bit{b}{1}$
\end{enumerate}

We'll deal with the first case
by recursively solving the $(n-1)$-bit instance $\finterval{\bits{a}{2}{n}}{\bits{b}{2}{n}}$
and adding one extra ternary vector.

We'll transform the second case
to an instance of spanning a true point interval Boolean function
of equal arity,
which can be solved optimally using a method introduced in \cite{Schieber2005154}.

\subsection{\texorpdfstring{$\bit{a}{1} = \bit{b}{1}$}{a[1] = b[1]}}
Let $\bit{a}{1} = \bit{b}{1} = 0$.
Note that the other case (\acrshort{msb} of $a$ and $b$ is $1$)
is symmetric so we'll only discuss the case of $0$.

Let $a_2 = \bits{a}{2}{n}$ and $b_2 = \bits{b}{2}{n}$.

Let $\mathcal{T}_2$ be the $(n-1)$-bit minimal spanning set of $\finterval{a_2}{b_2}$.
We can get such set by recursion.

Let $\mathcal{T}_0$ be the $n$-bit set we get by prepending each vector from $\mathcal{T}_2$ by $0$.

Let $\mathcal{T}_1 = \{ 1 \phi^{n-1} \}$.

Let $\mathcal{T} = \mathcal{T}_0 \cup \mathcal{T}_1$.

We claim that $\mathcal{T}$ spans exactly $\finterval{a}{b}$
and that $\mathcal{T}$ is minimal such. % TODO: Check grammar.

\begin{theorem}
$\mathcal{T}$ spans exactly $\finterval{a}{b}$.
\end{theorem}

\begin{proof}
% TODO: Reformat (split in two proofs?).
Part 1: $span(\mathcal{T}) \subseteq \finterval{a}{b}$

Let $c \in span(T)$, $T \in \mathcal{T}$.
We need to show that $c \in \finterval{a}{b}$.

\begin{enumerate}
\item $\bit{c}{1} = 1$: Since $\bit{b}{1} = 0$, necessarily $c > b$, so $c \in \finterval{a}{b}$.
\item $\bit{c}{1} = 0$: Necessarily $T \in \mathcal{T}_0$.
Let $T_2 = \bits{T}{2}{n}$ and $c_2 = \bits{c}{2}{n}$.
Since $T$ spans $c$, $T_2$ spans $c_2$.
By construction of $\mathcal{T}_0$ necessarily $T_2 \in \mathcal{T}_2$,
so $T_2$ doesn't span any number in $\interval{a_2}{b_2}$.
Thus $c_2 \in \finterval{a_2}{b_2}$.
Observe that prepending a $0$ bit to $c_2$, $a_2$ and $b_2$ preserves the interval membership:
$c_2 \in \finterval{a_2}{b_2} \Rightarrow 0 c_2 \in \finterval{0 a_2}{0 b_2}$.
Since $0 c_2 = c$, $0 a_2 = a$ and $0 b_2 = b$,
$c \in \finterval{a}{b}$.
\end{enumerate}

Part 2: $\finterval{a}{b} \subseteq span(\mathcal{T})$

Let $c \in \finterval{a}{b}$.
We need a $T \in \mathcal{T}$ that spans $c$.

\begin{enumerate}
\item $\bit{c}{1} = 1$: $1 \phi^{n-1} \in \mathcal{T}_1 \subseteq \mathcal{T}$ spans $c$.
\item $\bit{c}{1} = 0$:
Similarly to $a_2$ and $b_2$, let $c_2 = \bits{c}{2}{n}$.
Since $a$, $b$ and $c$ start with a $0$ bit,
$c_2 \in \finterval{a_2}{b_2}$.
Since $\mathcal{T}_2$ spans $\finterval{a_2}{b_2}$,
$\exists T_2 \in \mathcal{T}_2 . T_2$ spans $c_2$.
Prepending $0$ preserves spanning,
so $0 T_2 \in \mathcal{T}_0 \subseteq \mathcal{T}$ spans $c$.
\end{enumerate}
\end{proof}

\begin{theorem}
$\mathcal{T}$ is a minimal spanning set of $\finterval{a}{b}$.
\end{theorem}
\begin{proof}
Clearly $T_0$ optimally spans $\finterval{a}{b} \cap \interval{0^n}{0 1^{n-1}}$.

The optimal spanning set $\mathcal{T}_{opt}$ of $\finterval{a}{b}$
must span the binary vector $a' = 1 \bits{a}{2}{n} \in \finterval{a}{b}$.
Let $T \in \mathcal{T}_{opt}$ be a ternary vector that spans $a'$.
If $T$ spanned any vector that starts with $0$,
then $T$ would also span $a$,
which is a false point.
So $T$ can't span any number that starts with $0$.

This means we can't correctly generalize $T_0$
to span \emph{all} the true points of $\finterval{a}{b}$
as we need to add at least one independent ternary vector
to span the true point $a'$,
which is exactly what the algorithm does
(the independent vector $1 \phi^{n-1}$
spanning the whole $\interval{1 0^{n-1}}{1^n}$).
\end{proof}

We have shown that in case $\bit{a}{1} = \bit{b}{1}$,
our algorithm produces a sound and optimal result.
% TODO: Check vocabulary: sound

\subsection{\texorpdfstring{$\bit{a}{1} \neq \bit{b}{1}$}{a[1] != b[1]}}
Let $\bit{a}{1} \neq \bit{b}{1}$.
Since $a \leq b$, necessarily $\bit{a}{1} = 0$ and $\bit{b}{1} = 1$.

% TODO: Solve a=0 or b=1^n

By flipping the first bit in the external boundary values
$a - 1$ and $b + 1$,
we'll effectively reduce this case
to an instance of spanning a true point interval.

Let $a_1 = a - 1$ and $b_1 = b + 1$.
Note that these are exactly the external boundary values
of the interval $\interval{a}{b}$.
Also note that $\bit{a_1}{1} = 0$ and $\bit{b_1}{1} = 1$.

Let $a_1' = 1 \bits{a_1}{2}{n}$
and $b_1' = 0 \bits{b_1}{2}{n}$
(flipping the first bits of $a_1$ and $b_1$).
Note that $b_1' \leq a_1'$.

Let $\mathcal{T}_1'$ be the minimal spanning set
of the true point interval $\interval{b_1'}{a_1'}$.
This set can be computed efficiently
using the method introduced in \cite{Schieber2005154}.

Let's flip all the non-$\phi$ first bits
of vectors in $\mathcal{T}_1'$,
forming $\mathcal{T}$.
Note that $|\mathcal{T}| = |\mathcal{T}_1'|$
and also that all the vectors in $\mathcal{T}_1'$
and $\mathcal{T}$ have the length $n$.

We claim that $\mathcal{T}$ is an optimal spanning set
of $\finterval{a}{b}$.

\begin{theorem} \label{diffsound}
$\mathcal{T}$ spans exactly $\finterval{a}{b}$.
\end{theorem}

% TODO: Reformat the proofs
\begin{proof}
Part 1: $span(\mathcal{T}) \subseteq \finterval{a}{b}$

Let $c \in span(\mathcal{T})$.
We need to show that $c \in \finterval{a}{b}$.

Let $T \in \mathcal{T}$ span $c$.

Let $T' = \compl{\bit{T}{1}} \bits{T}{2}{n}$
(flipping the first bit).

By definition of $\mathcal{T}$,
$T' \in \mathcal{T}_1'$.

Let $c' = \compl{\bit{c}{1}} \bits{c}{2}{n}$
(flipping the first bit).
Note that $T'$ spans $c'$.

Since $\mathcal{T}_1'$ spans $\interval{b_1'}{a_1'}$
and $T' \in \mathcal{T}_1'$ spans $c'$,
$c' \in \interval{b_1'}{a_1'}$.

This means that $c' \geq b_1'$ and $c' \leq a_1'$.

Let $\bit{c'}{1} = 0$.
Since $\bit{b_1'}{1} = 0$ (by definition),
necessarily $\bits{c'}{2}{n} \geq \bits{b_1'}{2}{n}$.

Since $c = 1 \bits{c'}{2}{n}$
and $b_1 = 1 \bits{b_1'}{2}{n}$,
also $c \geq b_1$.

Since $b_1 = b + 1$,
$c > b$,
so $c \in \finterval{a}{b}$.

A symmetric argument can be shown for $\bit{c'}{1} = 1$
using $a_1'$.
\end{proof}

\begin{proof}
Part 2: $\finterval{a}{b} \subseteq span(\mathcal{T})$

Let $c \in \finterval{a}{b}$.
We need to show that $\mathcal{T}$ spans $c$.

Let $c' = \compl{\bit{c}{1}} \bits{c}{2}{n}$
(flipping the first bit in $c$).

We'll first show that $c' \in \interval{b_1'}{a_1'}$
(see definition of $b_1'$ and $a_1'$
in the algorithm description).

\begin{enumerate}
\item $\bit{c}{1} = 0$

From $\bit{b}{1} = 1$,
$c \in \finterval{a}{b}$
and $\bit{c}{1} = 0$,
we get $c < a$.

Then trivially $c \leq a_1 = a - 1$.

Since $\bit{a_1}{1} = 0 = \bit{c}{1}$,
the inequality is preserved after flipping the first bit,
i.e.~$c' \leq a_1'$.

Since $\bit{b_1'}{1} = 0$, we get $c' \geq b_1'$.

Altogether, we get $c' \in \interval{b_1'}{a_1'}$.
\item $\bit{c}{1} = 1$

This case is symmetric to the previous one.
Using an analogous argumentation,
we get $c' \in \interval{b_1'}{a_1'}$.
\end{enumerate}

Let $T' \in \mathcal{T}_1'$ span $c'$.
Such vector exists because
$\mathcal{T}_1'$ spans $\interval{b_1'}{a_1'}$
by definition
and $c' \in \interval{b_1'}{a_1'}$.

Let $T = \compl{\bit{T'}{1}} \bits{T'}{2}{n}$.
$T \in \mathcal{T}$ by definition.
$T$ spans $c$ because $T'$ spans $c'$
and flipping a fixed bit preserves spanning.

Thus $\mathcal{T}$ spans $c$.
\end{proof}

\begin{theorem}
$\mathcal{T}$ is a minimal spanning set of $\finterval{a}{b}$.
\end{theorem}

\begin{proof}
We'll prove the statement by contradiction.
Let the size of the minimal spanning set
of the interval $\interval{b_1'}{a_1'}$ be $k$.
Then trivially $|\mathcal{T}| = k$,
and $\mathcal{T}$ spans $\finterval{a}{b}$ as shown above.

% TODO: Consider clarifying spanning as "span exactly"
Let a set $\mathcal{T}_{k-1}$ of size $k-1$
span $\finterval{a}{b}$.
We'll use $\mathcal{T}_{k-1}$ to construct
a set of size $k-1$ that spans $\interval{b_1'}{a_1'}$,
reaching a contradiction
and thus rejecting the existence
of a smaller set spanning exactly $\finterval{a}{b}$.

Let $\mathcal{T}_{k-1}'$ be the result of flipping all
the non-$\phi$ first bits
of vectors in $\mathcal{T}_{k-1}$.
Trivially
$|\mathcal{T}_{k-1}'| = |\mathcal{T}_{k-1}| = k-1$.
We claim that $\mathcal{T}_{k-1}'$
spans $\interval{b_1'}{a_1'}$.

The proof is very similar
to the proof of theorem \ref{diffsound}:

% TODO: Clean up the following part of the proof
\begin{enumerate}
\item
$span(\mathcal{T}_{k-1}') \subseteq \interval{b_1'}{a_1'}$

Let $c' \in span(\mathcal{T}_{k-1}')$.
We'll show that $c' \in \interval{b_1'}{a_1'}$.

Let $T' \in \mathcal{T}_{k-1}'$ span $c'$.

Let $c = \compl{\bit{c'}{1}} \bits{c'}{2}{n}$
and $T = \compl{\bit{T'}{1}} \bits{T'}{2}{n}$.

$T \in \mathcal{T}_{k-1}$,
so $c \in \finterval{a}{b}$
by definition of $\mathcal{T}_{k-1}$.

\begin{enumerate}
\item $\bit{c'}{1} = 0$:

$\bit{c}{1} = 1$.

Since $c \in \finterval{a}{b}$, then $c > b$.

Then also
$c \geq b + 1 = b_1$
and
$c' \geq b_1'$.

Since $\bit{c'}{1} = 0$ and $\bit{a_1'}{1} = 1$,
then $c' \leq a_1'$.

Altogether $c' \in \interval{b_1'}{a_1'}$.

\item $\bit{c'}{1} = 1$: symmetric.
\end{enumerate}

\item
$\interval{b_1'}{a_1'} \subseteq span(\mathcal{T}_{k-1}')$

Let $c' \in \interval{b_1'}{a_1'}$.

Let $c = \compl{\bit{c'}{1}} \bits{c'}{2}{n}$.

We'll first show that $c \in \finterval{a}{b}$.

\begin{enumerate}
\item $\bit{c'}{1} = 1$:

$c' \leq a_1'$

$c \leq a_1$

$c < a$

$c \in \finterval{a}{b}$
\item $\bit{c'}{1} = 0$: symmetric.
\end{enumerate}

$\mathcal{T}_{k-1}$ spans $c$

$\mathcal{T}_{k-1}'$ spans $c'$
\end{enumerate}

Thus we have shown that $\mathcal{T}_{k-1}'$
spans exactly $\interval{b_1'}{a_1'}$.
Since $|\mathcal{T}_{k-1}'| = k-1$,
this contradicts the assumption that
the size of the minimal spanning set of the interval
$\interval{b_1'}{a_1'}$ is $k$.
Thus we reject the existence of a set of size $k-1$
spanning exactly $\finterval{a}{b}$,
proving that $\mathcal{T}$ constructed by our algorithm
($|\mathcal{T}| = k$)
is optimal.
\end{proof}

\section{Conclusions}
We have shown an linear (in the arity of numbers) time algorithm
for constructing minimal \acrshort{dnf} representation
of a false point interval Boolean function
specified by a pair of boundary values.

\bibliography{fibf}

\printglossaries

\end{document}
