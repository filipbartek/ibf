\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

% Theorem environments
\usepackage{amsthm}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[subsection]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

% Macros
\newcommand{\interval}[2]{[#1, #2]}
\newcommand{\finterval}[2]{\overline{\interval{#1}{#2}}}
\newcommand{\bit}[2]{#1^{[#2]}}
\newcommand{\bits}[3]{#1^{\interval{#2}{#3}}}
\newcommand{\booldom}{\mathbf{B}} % Boolean domain

\bibliographystyle{plain}

\usepackage{hyperref}
% http://en.wikibooks.org/wiki/LaTeX/Glossary#Jump_start
% Place \usepackage{glossaries} and \makeglossaries in your preamble (after \usepackage{hyperref} if present).

% Glossary
\usepackage{glossaries}
\newacronym{dnf}{DNF}{disjunctive normal form}
\newacronym{msb}{MSB}{most significant bit}
\makeglossaries

\author{Filip BÃ¡rtek}
\title{Minimal \acrshort{dnf} representation of false point interval Boolean functions}

\begin{document}
\maketitle

\section{Introduction}
When we identify binary vectors with the numbers they express in binary form,
we can define $n$-ary Boolean functions
as functions from $\{0, \ldots, 2^n - 1\}$ to the Boolean domain.
We continue to define \emph{false point interval Boolean functions}
as functions whose \emph{false} points,
when considered numbers,
form a single interval.

In this text,
I will show an efficient algorithm
for construction of minimal \acrshort{dnf} representation
(i.e.~one with the least clauses)
of false point interval Boolean functions.
Doing so, I will simplify the method shown in \cite{Dubovsky2012}.
I will build on the results about true point interval Boolean functions
shown in \cite{Schieber2005154}.

\section{Definitions}
% TODO: Define interval (esp. inclusiveness of boundary values)

\begin{definition}[Interval Boolean function]
Let $a \leq b$ be $n$-bit numbers ($0 \leq a \leq b \leq 2^n - 1$).
Then $f^n_{\interval{a}{b}}: \booldom{}^n \rightarrow \booldom{}$ is a function defined as follows:
% http://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#Using_aligned_braces_for_piecewise_functions
% http://en.wikipedia.org/wiki/Piecewise
\[f^n_{\interval{a}{b}} (x) = \left\{
  \begin{array}{lr}
    1 & $if $ x \in \interval{a}{b}\\
    0 & $otherwise$
  \end{array}
\right.
\]
\end{definition}

% TODO: Define interval complement `\finterval{a}{b}`

\begin{definition}[False point interval Boolean function]
Let $a \leq b$ be $n$-bit numbers ($0 \leq a \leq b \leq 2^n - 1$).
Then $f^n_{\finterval{a}{b}}: \booldom{}^n \rightarrow \booldom{}$ is a function defined as follows:
\[f^n_{\finterval{a}{b}} (x) = \left\{
  \begin{array}{lr}
    1 & $if $ x \notin \interval{a}{b}\\
    0 & $otherwise$
  \end{array}
\right.
\]
\end{definition}

% TODO: Define `span(T)`

Definitions of
ternary vectors,
spanning,
bit extraction $\bit{a}{i}$,
sequence extraction $\bits{a}{i}{j}$
etc.~are shown in \cite{Schieber2005154}.

\section{Spanning false point interval Boolean functions}
Let $n \geq 0$ and $0 \leq a \leq b \leq 2^n - 1$.
We need to find a set of ternary vectors of minimal cardinality
that spans exactly $\finterval{a}{b} = \interval{0}{a-1} \cup \interval{b+1}{2^n - 1}$.

Since we'll solve the problem recursively,
let's first simply observe that the optimal spanning set of a $0$-bit Boolean function ($n = 0$)
is an empty set.
From now on, let $n \geq 1$.

We'll consider two cases separately:

\begin{enumerate}
\item $\bit{a}{1} = \bit{b}{1}$
\item $\bit{a}{1} \neq \bit{b}{1}$
\end{enumerate}

We'll deal with the first case
by recursively solving the $(n-1)$-bit instance $\finterval{\bits{a}{2}{n}}{\bits{b}{2}{n}}$
and adding one extra ternary vector.

We'll transform the second case
to an instance of spanning a true point interval Boolean function
of equal arity,
which can be solved optimally using a method introduced in \cite{Schieber2005154}.

\subsection{\texorpdfstring{$\bit{a}{1} = \bit{b}{1}$}{a[1] = b[1]}}
Let $\bit{a}{1} = \bit{b}{1} = 0$.
Note that the other case (\acrshort{msb} of $a$ and $b$ is $1$)
is symmetric so we'll only discuss the case of $0$.

Let $a_2 = \bits{a}{2}{n}$ and $b_2 = \bits{b}{2}{n}$.

Let $\mathcal{T}_2$ be the $(n-1)$-bit minimal spanning set of $\finterval{a_2}{b_2}$.
We can get such set by recursion.

Let $\mathcal{T}_0$ be the $n$-bit set we get by prepending each vector from $\mathcal{T}_2$ by $0$.

Let $\mathcal{T}_1 = \{ 1 \phi^{n-1} \}$.

Let $\mathcal{T} = \mathcal{T}_0 \cup \mathcal{T}_1$.

We claim that $\mathcal{T}$ spans exactly $\finterval{a}{b}$
and that $\mathcal{T}$ is minimal such. % TODO: Check grammar.

\begin{theorem}
$\mathcal{T}$ spans exactly $\finterval{a}{b}$.
\end{theorem}

\begin{proof}
% TODO: Reformat (split in two proofs?).
Part 1: $span(\mathcal{T}) \subseteq \finterval{a}{b}$

Let $c \in span(T)$, $T \in \mathcal{T}$.
We need to show that $c \in \finterval{a}{b}$.

\begin{enumerate}
\item $\bit{c}{1} = 1$: Since $\bit{b}{1} = 0$, necessarily $c > b$, so $c \in \finterval{a}{b}$.
\item $\bit{c}{1} = 0$: Necessarily $T \in \mathcal{T}_0$.
Let $T_2 = \bits{T}{2}{n}$ and $c_2 = \bits{c}{2}{n}$.
Since $T$ spans $c$, $T_2$ spans $c_2$.
By construction of $\mathcal{T}_0$ necessarily $T_2 \in \mathcal{T}_2$,
so $T_2$ doesn't span any number in $\interval{a_2}{b_2}$.
Thus $c_2 \in \finterval{a_2}{b_2}$.
Observe that prepending a $0$ bit to $c_2$, $a_2$ and $b_2$ preserves the interval membership:
$c_2 \in \finterval{a_2}{b_2} \Rightarrow 0 c_2 \in \finterval{0 a_2}{0 b_2}$.
Since $0 c_2 = c$, $0 a_2 = a$ and $0 b_2 = b$,
$c \in \finterval{a}{b}$.
\end{enumerate}

Part 2: $\finterval{a}{b} \subseteq span(\mathcal{T})$

Let $c \in \finterval{a}{b}$.
We need a $T \in \mathcal{T}$ that spans $c$.

\begin{enumerate}
\item $\bit{c}{1} = 1$: $1 \phi^{n-1} \in \mathcal{T}_1 \subseteq \mathcal{T}$ spans $c$.
\item $\bit{c}{1} = 0$:
Similarly to $a_2$ and $b_2$, let $c_2 = \bits{c}{2}{n}$.
Since $a$, $b$ and $c$ start with a $0$ bit,
$c_2 \in \finterval{a_2}{b_2}$.
Since $\mathcal{T}_2$ spans $\finterval{a_2}{b_2}$,
$\exists T_2 \in \mathcal{T}_2 . T_2$ spans $c_2$.
Prepending $0$ preserves spanning,
so $0 T_2 \in \mathcal{T}_0 \subseteq \mathcal{T}$ spans $c$.
\end{enumerate}
\end{proof}

\begin{theorem}
$\mathcal{T}$ is a minimal spanning set of $\finterval{a}{b}$.
\end{theorem}
\begin{proof}
Clearly $T_0$ optimally spans $\finterval{a}{b} \cap \interval{0^n}{0 1^{n-1}}$.

The optimal spanning set $\mathcal{T}_{opt}$ of $\finterval{a}{b}$
must span the binary vector $a' = 1 \bits{a}{2}{n} \in \finterval{a}{b}$.
Let $T \in \mathcal{T}_{opt}$ be a ternary vector that spans $a'$.
If $T$ spanned any vector that starts with $0$,
then $T$ would also span $a$,
which is a false point.
So $T$ can't span any number that starts with $0$.

This means we can't correctly generalize $T_0$
to span \emph{all} the true points of $\finterval{a}{b}$
as we need to add at least one independent ternary vector
to span the true point $a'$,
which is exactly what the algorithm does
(the independent vector $1 \phi^{n-1}$
spanning the whole $\interval{1 0^{n-1}}{1^n}$).
\end{proof}

We have shown that in case $\bit{a}{1} = \bit{b}{1}$,
our algorithm produces a sound and optimal result.
% TODO: Check vocabulary: sound

\subsection{\texorpdfstring{$\bit{a}{1} \neq \bit{b}{1}$}{a[1] != b[1]}}
Let $\bit{a}{1} \neq \bit{b}{1}$.
Since $a \leq b$, necessarily $\bit{a}{1} = 0$ and $\bit{b}{1} = 1$.

% TODO: Solve a=0 or b=1^n

By flipping the first bit in the external boundary values
$a - 1$ and $b + 1$,
we'll effectively reduce this case
to an instance of spanning a true point interval.

Let $a_1 = a - 1$ and $b_1 = b + 1$.
Note that these are exactly the external boundary values
of the interval $\interval{a}{b}$.
Also note that $\bit{a_1}{1} = 0$ and $\bit{b_1}{1} = 1$.

Let $a_1' = 1 \bits{a_1}{2}{n}$
and $b_1' = 0 \bits{b_1}{2}{n}$
Note that $b_1' \leq a_1'$.

Let $\mathcal{T}_1'$ be the minimal spanning set
of the true point interval $\interval{b_1'}{a_1'}$.
This set can be computed efficiently
using the method introduced in \cite{Schieber2005154}.

Let's flip all the non-$\phi$ first bits
of vectors in $\mathcal{T}_1'$,
forming $\mathcal{T}$.
Note that $|\mathcal{T}| = |\mathcal{T}_1'|$
and also that all the vectors in $\mathcal{T}_1'$
and $\mathcal{T}$ have the length $n$.

We claim that $\mathcal{T}$ is an optimal spanning set
of $\finterval{a}{b}$.

\begin{theorem}
$\mathcal{T}$ spans exactly $\finterval{a}{b}$.
\end{theorem}

\begin{proof}
Part 1: $span(\mathcal{T}) \subseteq \finterval{a}{b}$
% TODO: Prove
Part 2: $\finterval{a}{b} \subseteq span(\mathcal{T})$
% TODO: Prove
\end{proof}

\begin{theorem}
$\mathcal{T}$ is a minimal spanning set of $\finterval{a}{b}$.
\end{theorem}

\begin{proof}
% TODO: Prove
\end{proof}

% TODO: Conclude

\bibliography{fibf}

\printglossaries

\end{document}
