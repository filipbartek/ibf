\chapter{Interval decomposition approximation algorithm
for \texorpdfstring{$k$}{k}-interval functions}
\todo[inline]{Finish the chapter.}
\todo[inline]{Define the algorithm properly.}

The $2k$-approximation
suffix-prefix decomposition algorithm
introduced in \autoref{chap:2kapprox}
can be naturally improved
by spanning each of the $k$ intervals
of the given $k$-interval function
optimally using the minimization algorithm
introduced in \autoref{chap:1interval}
(originally in \citet{Schieber2005154}).
We will call this improved algorithm
\quot{interval decomposition algorithm}.

Since the interval decomposition algorithm
clearly performs at least as well
as the suffix-prefix decomposition algorithm,
it is $2k$-approximation as well.
\citeauthor{Dubovsky2012} has managed
to prove that on $2$-interval functions,
the interval decomposition algorithm
has an approximation ratio $2$
\citep[p.~39]{Dubovsky2012}, % Theorem 4.2
while the suffix-prefix decomposition algorithm
has a tight approximation ratio $4$
on $2$-interval functions
(see \autoref{theorem:2kapproxtight}).
While this might lead us to expect
that the interval decomposition algorithm
performs significantly better in general,
we will show in this chapter that its approximation ratio
converges to $2k$ for large $k$
(and namely that it is strictly larger than $k$
for $k > 2$).
\todo{Do we really prove this for all $k$s? Try to!}

\section{Algorithm description}

\begin{description}
\item[Input] Numbers $a_1, b_1, \ldots, a_k, b_k$
that satisfy the inequalities
$\rep{0}{n} \leq a_1$,
$a_1 \leq b_1$,
$b_1 < a_2 - 1$,
\ldots,
$a_i \leq b_i$,
$b_i < a_{i+1} - 1$
(for $i \in \curly{1, \ldots, k-1}$),
\ldots,
$b_{k-1} < a_k - 1$,
$a_k \leq b_k$,
$b_k \leq \rep{1}{n}$.

Such numbers are endpoints of intervals
of a proper $k$-interval Boolean function.

\item[Output] A set of ternary vectors.

\item[Procedure]
The algorithm spans each of the intervals
$\interval{a_i}{b_i}$ separately.
For every $i$,
let $\mathcal{T}_i$ be the spanning set of the interval
$\interval{a_i}{b_i}$ returned by the $1$-interval
optimization algorithm
introduced in \autoref{chap:1interval}.
The algorithm returns
$\mathcal{T} = \bigcup_{i=1}^k{\mathcal{T}_i}$.
\end{description}

\section{Approximation-hard functions}

Let $l \geq 1$
denote the length of the interval prefix.
Then $k = 2^{l-1} + 1$
is the number of intervals
of the multi-interval function we construct.
Let $n \geq l+2$ be the target function arity.
We will construct
a proper $k$-interval $n$-ary function
that consists of $2$ short intervals and $2^{l-1} - 1$
long intervals.

The short intervals reside in the subtrees associated
with the prefixes $\rep{0}{l}$ and $\rep{1}{l}$:

\begin{itemize}
\item
$\interval{a_1}{b_1} =
\interval{\rep{0}{l} \; \rep{0}{n-l-1} 1}
{\rep{0}{l} \; \rep{1}{n-l-1} 0}$
\item
$\interval{a_k}{b_k} =
\interval{\rep{1}{l} \; \rep{0}{n-l-1} 1}
{\rep{1}{l} \; \rep{1}{n-l-1} 0}$
\end{itemize}

The long intervals reside in the remaining subtrees
and each of them intersects two of them:

\begin{itemize}
\item
$\interval{a_2}{b_2} =
\interval{\rep{0}{l-2} 01 \; \rep{0}{n-l-1} 1}{\rep{0}{l-2} 10 \; \rep{1}{n-l-1} 0}$
\item
$\interval{a_3}{b_3} =
\interval{\rep{0}{l-3} 011 \; \rep{0}{n-l-1} 1}{\rep{0}{l-3} 100 \; \rep{1}{n-l-1} 0}$
\item \vdots
\todo{Typeset better; esp. don't show the bullet here.}
\item
$\interval{a_{k-1}}{b_{k-1}} =
\interval{\rep{1}{l-2} 01 \; \rep{0}{n-l-1} 1}{\rep{1}{l-2} 10 \; \rep{1}{n-l-1} 0}$
\end{itemize}

In other words,
for $i \in \curly{2, \ldots, k-1 = 2^{l-1}}$,
the prefix of the endpoint $a_i$,
denoted $p_i$,
is the $l$-bit number $2 (i-2) + 1$
(note that $p_i$s exhaust all the odd numbers
between $1 = \rep{0}{l-2} \; 01$
and $2^l - 3 = \rep{1}{l-2} \; 01$).
Using $p_i$ we get the endpoints of the $i$-th interval:

\begin{itemize}
\item $a_i = (p_i \; \rep{0}{n-l-1} 1)$
\item $b_i = ((p_i + 1) \; \rep{1}{n-l-1} 0)$
\end{itemize}

Note that $a_i$ for every $i$
ends with the suffix $\rep{0}{n-l-1} 1$
($\bits{a_i}{l+1}{n} = \rep{0}{n-l-1} 1$)
and $b_i$ always ends with the suffix $\rep{1}{n-l-1} 0$.
The $l$-bit prefixes of $a_i$ and $b_i$
are either equal
in case $i \in \curly{1, k}$,
or successive numbers in case
$i \in \curly{2, \ldots, k-1}$.

We claim that $f =
f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$
can be spanned with as few as $n$
\todo{Really?}
ternary vectors,
while the approximation algorithm produces a spanning set
of size [?].
\todo{Insert the number here.}

\begin{lemma}
[$dnf(f) \leq n$]
The function
$f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$
defined above can be spanned with as few as $n$ vectors.
\end{lemma}

\begin{proof}
First observe that $f$
has a limited number of false points,
as each pair of successive intervals
is separated by just two false points
and there are just two false points
which do not lie between the intervals
(they are the two extreme outer points
$\rep{0}{n}$ and $\rep{1}{n}$).
There are $2k$ false points in total,
each of them being either $a_i - 1$ or $b_i + 1$
for some $i$.

To span $f$,
we first span the intervals
$\interval{j \; \rep{0}{n-l-1} 1}{j \; \rep{1}{n-l-1} 0}$
for every $j \in \booldom^l$.
The set
$\mathcal{T}_{in} =
\curly{\phi^l \; s |
s \text{ is a cyclic shift of } 01 \phi^{n-l-2}}$
exactly spans the union of the intervals
$\interval{j \; \rep{0}{n-l-1} 1}{j \; \rep{1}{n-l-1} 0}$.
To see that it actually does,
observe that for every $j$,
we want to span all the vectors with prefix $j$
except the two vectors $(j \; \rep{0}{n-l})$
and $(j \; \rep{1}{n-l})$.
The cyclic shifts of $01 \phi^{n-l-2}$ span exactly
all the numbers with the exception of
$\rep{0}{n-l}$ and $\rep{1}{n-l}$,
since every number that contains both a $0$ and a $1$
has some position $i$ such that
$\bit{x}{i} = 0$
and $\bit{x}{(i+1) \mod (n-l)} = 1$.
The size of $\mathcal{T}_{in}$ is clearly $n-l$.

We are left with two true points to span
in each of the long intervals.
There are $k-2 = 2^{l-1} - 1$ long intervals.
Spanning each of the remaining true points separately,
we get $\mathcal{T}_{out}$ of size
$2(k-2) = 2(2^{l-1}-1) = 2^l - 2$.
\todo[inline]{Use a better algorithm -- one that produces merely $n+l-2$ vectors.}

%In total we use
%$2^l$ vectors to span $f$.
\end{proof}

\begin{center}
\begin{tabular}{l|llll}
$l$
& $k = 2^{l-1} + 1$
& $\size{\mathcal{T}_{approx}} = 2^l (n-l)$
& $\size{\mathcal{T}} = n + l - 2$
& $\lim_{n \rightarrow \infty}
{\frac{\size{\mathcal{T}_{approx}}}{\size{\mathcal{T}}}}$
\\
\hline
$1$ & $2$ & $2n-4$ & $n-1$ & $2$ \\
$2$ & $3$ & $4n-8$ & $n$ & $4$ \\
$3$ & $5$ & $8n-24$ & $n+1$ & $8$ \\
$4$ & $9$ & $16n-64$ & $n+2$ & $16$
\end{tabular}
\end{center}

\[
\lim_{n \rightarrow \infty}{
\frac{\size{\mathcal{T}_{approx}}}{\size{\mathcal{T}}}
}
=
2^l
\]

\[
\lim_{l \rightarrow \infty}{
\frac{
\lim_{n \rightarrow \infty}{
\frac{\size{\mathcal{T}_{approx}}}{\size{\mathcal{T}}}
}
}{k}
}
=
2
\]

\todomaybe[inline]{oznac horni cast jako funkci k}
\todo{lim sup ~ horni odhad limity - pres k
nebo lim pres l + justification v uvodu dukazu (lepsi) - beru jen nektera k}

\todo[inline]{Finish.}
