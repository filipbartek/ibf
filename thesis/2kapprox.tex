\chapter{\approxtitle{Suffix-prefix decomposition}}
\label{chap:2kapprox}
\todo[inline]{Rename the algorithm to \quot{suffix-prefix decomposition algorithm}.}

In this chapter
we shall show a simple $2k$-approximation algorithm for the following problem:
\emph{Given a proper $k$-interval function $f$,
find a minimum spanning set of $f$.}
We shall assume that the function $f$ is represented by pairs of endpoints of the respective intervals.
The algorithm we shall describe is a straightforward
\todo{Check whether it really is straightforward.}
extension of
\citeauthor{Schieber2005154}'s suffix-prefix
approximation algorithm
for disjoint spanning sets of $1$-interval functions
\citep[section 6]{Schieber2005154}.
\todomaybe{Rephrase here or in Conclusion (almost identical sentence).}

In the rest of this chapter,
we will only consider
\emph{proper} $k$-interval Boolean functions,
that is those whose adjacent intervals are separated by
at least one false point
(see \cref{def:properkibf}).
% \autoref doesn't recognize definitions,
% so we're better of with \cref.
A $k$-interval Boolean function
which is not proper $k$-interval
can be efficiently reduced to a proper $l$-interval
where $l < k$
by joining the adjoint
intervals.

\section{Description of the algorithm}
\todo{Unite with the following chapter.}

\begin{description}
\item[Input] Numbers $a_1, b_1, \ldots, a_k, b_k$
that satisfy the inequalities
$\rep{0}{n} \leq a_1$,
$a_1 \leq b_1$,
$b_1 < a_2 - 1$,
\ldots,
$a_i \leq b_i$,
$b_i < a_{i+1} - 1$
(for $i \in \curly{1, \ldots, k-1}$),
\ldots,
$b_{k-1} < a_k - 1$,
$a_k \leq b_k$,
$b_k \leq \rep{1}{n}$.

Such numbers are the endpoints of the intervals
of the proper $k$-interval Boolean function $\fnkab$.

\item[Output] A spanning set of $\fnkab$.
\todo{Update in the interval decomposition algorithm.}

\item[Procedure]
The algorithm spans each of
the intervals $\interval{a_i}{b_i}$ separately.
The set that spans $\interval{a_i}{b_i}$ will be denoted
$\mathcal{T}_i$,
and the output set will be denoted
$\mathcal{T} = \bigcup_{i=1}^k{\mathcal{T}_i}$.

Let's consider the interval $\interval{a_i}{b_i}$.
Let $c$ be the longest common prefix of $a_i$ and $b_i$
and let $j$ be its length.

If $j = n$, that is $c = a_i = b_i$,
$\mathcal{T}_i$ consists of the single vector
$c = a_i = b_i$.

We are left with the situation $j < n$.

Note that $\bit{a_i}{j+1} = 0$ and $\bit{b_i}{j+1} = 1$,
since $a_i \leq b_i$ and $a_i \neq b_i$.
Now let $a' = \bits{a_i}{j+2}{n}$
and $b' = \bits{b_i}{j+2}{n}$
($a_i = c 0 a'$ and $b_i = c 1 b'$).
Optimally span the suffix interval
$\interval{a'}{\rep{1}{n-j-1}}$
and the prefix interval
$\interval{\rep{0}{n-j-1}}{b'}$
using the
algorithm
introduced in \cref{sec:prefixsuffix}
and producing spanning sets
$\mathcal{T}_{i, 0}'$
and $\mathcal{T}_{i, 1}'$ respectively.
Now simply prepend $\bits{a_i}{1}{j+1} = c 0$
to all vectors in $\mathcal{T}_{i, 0}'$
and $\bits{b_i}{1}{j+1} = c 1$
to all vectors in $\mathcal{T}_{i, 1}'$,
producing $\mathcal{T}_{i, 0}$
and $\mathcal{T}_{i, 1}$ respectively.
The spanning set of $\interval{a_i}{b_i}$
is then
$\mathcal{T}_i
= \mathcal{T}_{i, 0} \cup \mathcal{T}_{i, 1}$.
\end{description}

\todomaybe[inline]{Treat more efficiently the cases
$\bits{a_i}{j+1}{n} = \rep{0}{n-j}$ (prefix)
and $\bits{b_i}{j+1}{n} = \rep{1}{n-j}$ (suffix),
especially $a_1 = \rep{0}{n}$
and $b_k = \rep{1}{n}$.
This doesn't improve the approximation ratio though
and may complicate the proof.}
\todokucera[inline]{Můžete to dát do poznámky k algoritmu, jako „possible improvements“ s tím, že to nehraje roli pro aproximační poměr, ale v některých případech to může být užitečné.}

\section{Feasibility}
\begin{theorem}
The algorithm spans exactly
$f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$.
\end{theorem}

\begin{proof}
We need to show that for each $i$,
$\mathcal{T}_i$ spans exactly $\interval{a_i}{b_i}$.
This is obvious in case $j = n$.

In the remaining case $j < n$,
observe that
$0 \mathcal{T}_{i, 0}'
= \curly{0 T | T \in \mathcal{T}_{i, 0}'}$
spans exactly the interval
$\interval{0 a'}{0 \rep{1}{n-j-1}}$
and $1 \mathcal{T}_{i, 1}'$
spans exactly the interval
$\interval{1 \rep{0}{n-j-1}}{1 b'}$.
Since $1 \rep{0}{n-j-1} = 0 \rep{1}{n-j-1} + 1$,
the union of these sets
spans exactly the interval
$\interval{0 a'}{1 b'}
= \interval{\bits{a_i}{j+1}{n}}{\bits{b_i}{j+1}{n}}$.
Prepending the common prefix $c$ to
$0 \mathcal{T}_{i, 0}' \cup 1 \mathcal{T}_{i, 1}'$
preserves the spanning to
$\interval{a_i}{b_i}$
and matches the operation performed in the algorithm
to produce $\mathcal{T}_i$.

The union of such $\mathcal{T}_i$s clearly spans exactly
the union of the intervals.
\end{proof}

\section{Approximation ratio}

\todo[inline]{Unite terminology with chapter "betterapprox".}

\begin{theorem}
\label{theorem:2kapproxratio}
Let $\mathcal{T}_{opt}$ be an optimal spanning set of
$f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$
and let $\mathcal{T}$ be the spanning set returned
by the algorithm.
We claim that:
\begin{equation*}
|\mathcal{T}| \leq 2k |\mathcal{T}_{opt}|
\end{equation*}
\end{theorem}

\begin{proof}
To prove the statement,
we will show an orthogonal set $V$ of the function
$f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$
of size
$\size{V} \geq \frac{\size{\mathcal{T}}}{2k}$.
By \autoref{theorem:orthodnf},
the existence of such orthogonal set
gives a lower bound $\size{V}$
on $\size{\mathcal{T}_{opt}}$.

First, let's consider the case that
$\size{\mathcal{T}_i} = 1$ for every $i$.
Note that this can only happen if
$a_i = b_i$ for every $i$.
In this case,
the orthogonal set $V$ consists of the single vector $a_1$
(in fact, we could use any true point
as every set of size $1$ is trivially orthogonal).
Since $\size{\mathcal{T}_i} = 1$
for every $i \in \curly{1, \ldots, k}$,
$\size{\mathcal{T}} = k$.
It is now easy to see that
$\size{V} = 1
\geq \frac{1}{2} = \frac{k}{2k} =
\frac{\size{\mathcal{T}}}{2k}$.

We are now left with the case that
$\size{\mathcal{T}_i} > 1$ for some $i$.
Note that this can only happen if
the length $j$
of the longest common prefix
of the corresponding endpoints $a_i$ and $b_i$
is strictly smaller than $n$.
Note that
$\mathcal{T}_i
= \mathcal{T}_{i,0} \cup \mathcal{T}_{i,1}$
for all $i$ such that $\size{\mathcal{T}_i} > 1$.

Let $\mathcal{T}_{i, \alpha}$
($i \in \curly{1, \ldots, k}, \alpha \in \booldom$)
be the largest
of the partial spanning sets of this type
\todomaybe{Clarify more -- what is \quot{this type}?}
produced during the course of the algorithm.
Note that the corresponding
$\mathcal{T}_i
= \mathcal{T}_{i, \alpha}
\cup \mathcal{T}_{i, \compl{\alpha}}$
need not be the largest of the interval spanning sets
in case
$\mathcal{T}_{i, \compl{\alpha}}$ is small.

Without loss of generality,
\todomaybe{Discuss soundness, for example \quot{The complementary case is symmetric.}.}
let $\alpha = 1$.
The set $\mathcal{T}_{i, 1}'$
that spans exactly
$\interval{\rep{0}{n-j-1}}{b' = \bits{b_i}{j+2}{n}}$
was in this case obtained
using the prefix algorithm
introduced in \cref{sec:prefix}.
In the proof of optimality of this algorithm
(see \autoref{proof:prefixoptimal}),
we showed an orthogonal set that matches the size
of the spanning set produced by the algorithm.
Let's call this set $V_{i, 1}'$.
%In \autoref{corollary:prefixdependence}
%we showed that the orthogonality of $V_{i, 1}'$
%only depends on the false point
%$b' + 1$.
%Let $V_{i, 1}'$ be this orthogonal set
%of $\interval{\rep{0}{n-j-1}}{b'}$
%($\size{V_{i, 1}'}
%= \size{\mathcal{T}_{i, 1}'}$).
Recall that by \cref{corollary:prefixdependence}
all the pairs of vectors in $V_{i, 1}'$
collide on the false point $b' + 1$
of $\prefixfn{f}{n-j-1}{b'}$.

Let $V = \curly{c 1 v | v \in V_{i, 1}'}$,
where $c$ is the longest common prefix of $a_i$ and $b_i$.
We claim that $V$ is an orthogonal set of
$\fnkab$.

Let $c1x, c1y \in V$, $x \neq y$.
Since by \cref{corollary:prefixdependence}
$x$ and $y$ collide on $b'+1$,
$c1x$ and $c1y$ collide on
$c1(b'+1) = b_i+1$.
\todo{What if $b_i = \rep{1}{n}$? Then $\size{V}=1$, which is handled separately in the proof of optimality.}
To see that $b_i+1$ is a false point,
note that $b_i < a_{i+1} - 1$
\todo{What if $i = k$?}
by the requirements on input data
(we only consider \emph{proper} $k$-interval functions).

It follows that $V$ is orthogonal
with respect to $\fnkab$.
From \autoref{theorem:orthodnf} we get
$\size{\mathcal{T}_{opt}} \geq \size{V}$.

Since $\mathcal{T}_{i, \alpha}$ is
the largest of the at most $2k$ spanning sub-sets
of this type
and the spanning sets of the other types are of size $1$,
%and less numerous,
\todo{Clarify.}
necessarily
$\size{\mathcal{T}} \leq 2k \size{\mathcal{T}_{i, \alpha}}
= 2k \size{V} \leq 2k \size{\mathcal{T}_{opt}}$.
\end{proof}

Note that the spanning set returned by the algorithm
is disjoint.
This makes the algorithm $2k$-approximation
for the disjoint case as well:

\begin{theorem}
Let $\mathcal{T}_{disjoint}$ be an optimal \emph{disjoint}
spanning set of
$f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$
and let $\mathcal{T}$ be the (disjoint)
spanning set returned by our algorithm.
We claim that:
\begin{equation*}
|\mathcal{T}| \leq 2k |\mathcal{T}_{disjoint}|
\end{equation*}
\end{theorem}

\begin{proof}
Since every disjoint spanning set
is a spanning set in general,
$\size{\mathcal{T}_{opt}} \leq
\size{\mathcal{T}_{disjoint}}$,
where $\mathcal{T}_{opt}$ is an optimal
(not necessarily disjoint)
spanning set of
$f^n_{\interval{a_1}{b_1}, \ldots, \interval{a_k}{b_k}}$.

Using \autoref{theorem:2kapproxratio} we get:

\begin{equation*}
|\mathcal{T}| \leq 2k |\mathcal{T}_{opt}|
\leq 2k |\mathcal{T}_{disjoint}|
\end{equation*}
\end{proof}

\begin{theorem}
\label{theorem:2kapproxtight}
The approximation ratio of $2k$ is tight.
\end{theorem}

\begin{proof}
For every $k$ that is a power of $2$
we will show a $k$-interval function such that
$|\mathcal{T}| = 2k |\mathcal{T}_{opt}|$
(following the notation from
\autoref{theorem:2kapproxratio}).

Let $k = 2^{n_k}$.
Let $P$ be all the $n_k$-bit numbers,
that is $P = \booldom^{n_k}$.
Note that $|P| = 2^{n_k} = k$.
Let $n = n_k + 3$.

For each $p \in P$,
we define the interval $\interval{a_p}{b_p}$
by appending certain $3$-bit suffixes to $p$:

\begin{itemize}
\item $a_p = p 000$
\item $b_p = p 011$
\end{itemize}

The first appended bit
($0$ for $a_p$ and $0$ for $b_p$)
ensures that there is at least one false point
between any pair of intervals defined this way
(all the points that have a $1$ in their $(n_k + 1)$-st
position are false points).

The remaining pair of appended bits
($00$ for $a_p$ and $11$ for $b_p$)
ensures that
$\bits{a_p}{1}{n-1} \neq \bits{b_p}{1}{n-1}$,
so the algorithm will span the sub-intervals
$\interval{a_p = p 000}{p 001}$
and $\interval{p 010}{b_p = p 011}$ separately,
producing at least $2$ vectors to span
$\interval{a_p}{b_p}$.
The configuration also enables
the interval $\interval{a_p}{b_p}$
to be spanned by the single ternary vector
$p 0 \rep{\phi}{2}$.

Thus we have $k$ intervals
none of which intersect or are adjoint
\todomaybe{Rephrase.}.

Since $P = \booldom^{n_k}$,
we can span all the intervals by the single ternary vector
$\rep{\phi}{n_k} 0 \rep{\phi}{2}$.
Clearly $\size{\mathcal{T}_{opt}} = 1$.

However,
the approximation algorithm uses $2k$ vectors to span
the intervals,
since it spans each of the intervals separately
and uses the two vectors
$p 0 0 \phi, p 0 1 \phi$
for each interval.

We get
$|\mathcal{T}| = 2k = 2k |\mathcal{T}_{opt}|$.

Note that the optimal spanning set is trivially disjoint,
so the ratio is tight in disjoint case as well.
\end{proof}
